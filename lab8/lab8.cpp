#include <iostream>
#include <stdexcept>

using namespace std;

template <typename ElementType>//пояснення в NOTES нижче
class Stack {
private:
    ElementType* stackArray;         // Динамічний масив для зберігання елементів
    int maxSize;           // Максимальний розмір стеку
    int top;               // Індекс верхнього елементу стеку

public:
    // Конструктор
    Stack(int size) {
        if (size <= 0) throw invalid_argument("Size must be positive"); //розмір стеку завжди позитивний
        maxSize = size;


        stackArray = new ElementType[maxSize];// виділяється динамічно за допомогою new, щоб зберігати maxSize елементів.


        top = -1;//Ініціалізується значенням -1, що означає, що стек порожній.
    }

    

    // Додавання елементу в стек (перевантаження операції +) ============================================            +
    Stack& operator + (const ElementType& element) {
        if (top == maxSize - 1) {//перевірка, на всякий випадок, якщо стек буде переповнений
            throw overflow_error("Stack is full");
        }
        stackArray[++top] = element;
        return *this;
        /*
        Елемент додається до масиву, і top збільшується на 1.
        Повертається посилання на сам об'єкт (*this), що дозволяє ланцюгові виклики.
        */
    }

    // Витягування елементу з стеку (перевантаження операції -) =================================================               -
    Stack& operator - (ElementType& element) {
        if (top == -1) {//перевірка, на всякий випадок, якщо стек буде пустим
            throw underflow_error("Stack is empty");
        }
        element = stackArray[top--];
        return *this;
        /*
        Витягується елемент з масиву, а top зменшується на 1.
        Витягнутий елемент передається в змінну element.
        */
    }
    
    

    // Показати верхній елемент (без його вилучення).
    ElementType peek() const { 
     /*   Дозволяє отримати верхній елемент стеку без його вилучення,
          а також забезпечує перевірку, щоб уникнути доступу до порожнього стеку.
          Якщо стек порожній, вона видає помилку, а якщо ні, повертає значення верхнього елемента.    */
    
        if (top == -1) throw underflow_error("Stack is empty");
        return stackArray[top];
    }

    



    
    ~Stack() {// Деструктор
        delete[] stackArray;
        cout << "\n Destructor automaticly deleted Class Stack\n";
    }
};


int main() {//=======================================================================================================              MAIN
    
        Stack<int> intStack(5);
        /*
        Створення об'єкта:
            intStack — це об'єкт (екземпляр) класу Stack.
            Це стек, який зберігатиме елементи типу int (цілі числа).
        Використання шаблону:
            Оскільки клас Stack є шаблоном (template), 
            тут зазначено, що типом даних, який буде використовуватись у стеку, є int.
            Тобто, стек буде зберігати тільки цілі числа.
        Виклик конструктора:
            Значення 5 передається до конструктора класу Stack, який визначає розмір стеку. 
            Cтек intStack зможе вміщувати до 5 елементів.
            Конструктор виділяє пам'ять для збереження цих елементів у динамічному масиві.
        */



        int element;//зберігання значення, яке буде витягнуто зі стеку під час операції вилучення елементу

        // Додавання елементів в стек, юзаю (+) перевантажений оператор
        intStack + 10;
        intStack + 20;
        intStack + 30;
        //intStack + 40;

        cout << "Top element: " << intStack.peek() << endl;

        // Витягування елементів через перевантажені знаки
        intStack - element;//Витягується верхній елемент стеку і зберігається в змінній element.
        cout << "Popped element: " << element << endl;

        cout << "Top element after pop: " << intStack.peek() << endl;

    
   
        
        
        
    return 0;
}
//============================================================================                          NOTES
/*
*   #include <iostream>
    #include <stdexcept>

    using namespace std;

    template <typename ElementType>                  <----------
* 
* 
* 
Рядок template <typename ElementType> вказує на те,
що клас Stack є шаблоном(template), що дозволяє створювати стеки, 
які можуть містити елементи будь - якого типу даних.


typename ElementType: Цей фрагмент оголошує параметр шаблону з ім'ям ElementType. 
    Коли ви створюєте об'єкт класу Stack, вказуєтья, який тип даних повинен використовуватись замість ElementType. 
    Наприклад, якщо створюється Stack<int>, то ElementType стане int, і стек зможе зберігати тільки цілі числа.

Використання параметра шаблону: 
    У класі Stack параметр ElementType використовується для визначення типу елементів, 
    які будуть зберігатись у динамічному масиві stackArray,
    а також для визначення типів аргументів і значень, 
    які використовуються в методах класу (наприклад, в перевантажених операціях + і -).

Завдяки цій конструкції, можна створювати стеки для різних типів, наприклад:

    Stack<int> для стека з цілими числами.
    Stack<double> для стека з числами з плаваючою комою.
    Stack<string> для стека з рядками.

*/